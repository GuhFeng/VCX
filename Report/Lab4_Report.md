# ***Lab4 Report***

## Task 1: Inverse Kinematics

在这一部分中，我实现了前向运动学和逆向运动学。

### 前向运动学

给定每个关节相对于父关节的平移量以及每个关节的局部旋转，我们求出每个关节在世界坐标系下的位置和旋转。

### CCD IK

在这一部分中，我实现了CCD IK算法，使用迭代法逼近目标位置。在每一次迭代过程中，从末端开始遍历每一关节，旋转当前段的机械臂使得这个关节与末端的连线指向目标节点，直到末端与目标足够近或者达到迭代次数的上限。

### FABR IK

在这一部分中，我实现了FABR IK算法，同样也是使用迭代法逼近目标。每一次迭代包括后向传播和前向传播。后向传播中，从末端开始遍历关节，计算每一个关节的对应位置，其中，末端的对应位置是目标位置。对于中间关节，将子关节放在对应位置，然后沿着子关节指向该关节的方向，利用关节长度计算出关节的对应位置。前向传播类似，从根关节开始遍历，根关节对应位置是自己的原始位置，然后同理计算出每一个关节的对应位置，并作为该关节的下一次迭代时全局位置。同CCD IK，迭代直到末端与目标足够近或者达到迭代次数的上限。

### Custom Target

在这个任务中，我定义了一条螺旋线，由机械臂进行绘制。

### 问题

1. IK迭代中会不断尝试指向目标，如果迭代次数足够，在后面的迭代中，IK会不动，保持指向目标。
2. FABR IK的迭代次数会比CCD IK小不少。
3. 我们应该限制解的范围，使得关节的位置变化不能够太大。

## Mass-Spring System

在这一部分中，我实现了隐式欧拉的弹簧质点系统。为了实现的方便，我分别加入了函数 `void partial_g((MassSpringSystem & system, std::vector<glm::vec3> & x, std::vector<glm::vec3> & y, std::vector<glm::vec3> & b, float h))`和函数 `void partial2_g(MassSpringSystem & system, std::vector<glm::vec3> & x, std::vector<glm::vec3> & y, std::vector<TRP> & A, float h)`来求能量函数$g$关于位置$x$的梯度和Hassan矩阵。此外，我们还要注意处理固定的点，这些点对应的各阶导数全为0。而后只要对照课件，计算出$y$，用牛顿迭代法，即可解出$x$和$v$。
