void SimplifyMesh(
    Engine::SurfaceMesh const & input,
    Engine::SurfaceMesh &       output,
    float                       valid_pair_threshold,
    float                       simplification_ratio) {
    // your code here
    double t             = valid_pair_threshold * valid_pair_threshold;
    size_t n             = input.Positions.size();
    size_t numIterations = n - n * simplification_ratio;
    DCEL   links;
    links.AddFaces(input.Indices);
    glm::mat4 * Q = new glm::mat4[n];
    memset(Q, 0, sizeof(glm::mat4) * n);

    // 为每个初始顶点计算二次代价矩阵
    for (size_t i = 0; i < n; i++) {
        DCEL::Vertex                        v     = links.GetVertex(i);
        std::vector<DCEL::Triangle const *> faces = v.GetFaces();
        for (DCEL::Triangle const * f : faces) {
            size_t    idx1 = *(f->Indices(0)), idx2 = *(f->Indices(1)), idx3 = *(f->Indices(2));
            glm::vec3 v1 = input.Positions[idx1], v2 = input.Positions[idx2],
                      v3 = input.Positions[idx3];
            // 计算平面参数
            double a = (v2.y - v1.y) * (v3.z - v1.z) - (v2.z - v1.z) * (v3.y - v1.y),
                   b = (v3.x - v1.x) * (v2.z - v1.z) - (v2.x - v1.x) * (v3.z - v1.z),
                   c = (v2.x - v1.x) * (v3.y - v1.y) - (v3.x - v1.x) * (v2.y - v1.y),
                   d = -(a * v1.x + b * v1.y + c * v1.z), tmp = sqrt(a * a + b * b + c * c);
            double fp[4] = { a / tmp, b / tmp, c / tmp, d / tmp };

            // glm::mat4按列存储，但Q为对称矩阵，故无需特别处理
            for (size_t j = 0; j < 4; j++) {
                for (size_t k = 0; k < 4; k++) { Q[i][j][k] += fp[j] * fp[k]; }
            }
        }
    }

    // 选择所有合法的顶点对
    std::vector<std::pair<size_t, size_t>> v_pair = std::vector<std::pair<size_t, size_t>>();
    for (size_t i = 0; i < n - 1; i++) {
        DCEL::Vertex          v           = links.GetVertex(i);
        std::vector<uint32_t> v_neighbors = v.GetNeighbors();
        std::set<uint32_t>    neighbors   = std::set<uint32_t>();
        for (size_t j = 0; j < v_neighbors.size(); j++) { neighbors.insert(v_neighbors[j]); }
        for (size_t j = i + 1; j < n; j++) {
            if (neighbors.count(j)) {
                v_pair.push_back(std::pair(i, j));
            } else {
                if (t <= 0) continue;
                glm::vec3 v1 = input.Positions[i], v2 = input.Positions[j];
                if ((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y)
                        + (v1.z - v2.z) * (v1.z - v2.z)
                    < t) {
                    v_pair.push_back(std::pair(i, j));
                }
            }
        }
    }
    size_t pair_cnt = v_pair.size();

    // 对于每一个顶点对，求解最优的收缩点，并计算它的代价
    std::vector<glm::vec4> pair2point = std::vector<glm::vec4>();
    std::vector<double>    pair2cost  = std::vector<double>();
    for (size_t i = 0; i < pair_cnt; i++) {
        size_t    v1 = v_pair[i].first, v2 = v_pair[i].second;
        glm::mat4 q = Q[v1] + Q[v2];
        // 注意glm::mat4按列存储
        glm::mat4 tmp_mat = glm::mat4(
            q[0][0],
            q[0][1],
            q[0][2],
            0,
            q[0][1],
            q[1][1],
            q[1][2],
            0,
            q[0][2],
            q[1][2],
            q[2][2],
            0,
            q[0][3],
            q[1][3],
            q[2][3],
            1);
        glm::mat4 inv_mat = glm::inverse(tmp_mat);
        glm::vec4 v_bar   = inv_mat * glm::vec4(0, 0, 0, 1);
        pair2point.push_back(v_bar);
        pair2cost.push_back(
            v_bar.x * ((q * v_bar).x) + v_bar.y * ((q * v_bar).y) + (v_bar.z * (q * v_bar).z)
            + (v_bar.w * (q * v_bar).w));
    }

    // 迭代地从顶点对中找出代价最小的那一对进行顶点合并，直到剩余顶点的数量小于所需的比例
    output          = Engine::SurfaceMesh(input);
    bool * pair_vis = new bool[pair_cnt]; // 记录顶点对是否被合并
    memset(pair_vis, 0, sizeof(bool) * pair_cnt);

    for (size_t i = 0; i < numIterations; i++) {
        // 找到代价最小的顶点对
        // std::cout << i << std::endl;
        double min_cost = INFINITY;
        size_t min_pair = pair_cnt;
        for (size_t j = 0; j < pair_cnt; j++) {
            if (pair_vis[j]) continue;
            if (min_cost > pair2cost[j]) {
                min_pair = j;
                min_cost = pair2cost[j];
            }
        }

        // DCEL links;
        // links.AddFaces(output.Indices);
        // Engine::SurfaceMesh tmp = Engine::SurfaceMesh(output);

        // if (! links.IsValid()) {
        //     // we check if the mesh is valid
        //     std::cout << i << std::endl;
        //     break;
        // }

        // std::cout << min_pair << std::endl;
        // std::cout << v_pair[min_pair].first << " " << v_pair[min_pair].second << std::endl;

        // 对点更新
        output.Positions[v_pair[min_pair].first] = glm::vec3(pair2point[min_pair]);

        // 对面更新
        // output.Indices                            = std::vector<std::uint32_t>();

        // DCEL::Vertex                        v     = links.GetVertex(v_pair[min_pair].second);
        // std::vector<DCEL::Triangle const *> faces = v.GetFaces();
        // for (DCEL::Triangle const * f : faces) {
        //     size_t idx = links.IndexOf(f);

        //     // std::cout << idx << std::endl;
        //     // std::cout << 3 * idx << std::endl;
        //     // std::cout << output.Indices.size() << std::endl;

        //     for (size_t j = 3 * idx; j < 3 * idx + 3; j++) {
        //         if (output.Indices[j] == v_pair[min_pair].second) {
        //             output.Indices[j] = v_pair[min_pair].first;
        //         }
        //     }
        //     // if (output.Indices[3 * idx] == output.Indices[3 * idx + 1]
        //     //     || output.Indices[3 * idx] == output.Indices[3 * idx + 2]
        //     //     || output.Indices[3 * idx + 1] == output.Indices[3 * idx + 2]) { //
        //     消除退化的面
        //     //     output.Indices.erase(output.Indices.begin() + 3 * idx, output.Indices.begin()
        //     + 3 * idx + 3);
        //     // }
        // }

        for (size_t j = 0; j < output.Indices.size(); j += 3) {
            for (size_t k = 0; k < 3; k++) {
                if (output.Indices[j + k] == v_pair[min_pair].second) {
                    output.Indices[j + k] = v_pair[min_pair].first;
                }
            }
            if (output.Indices[j] == output.Indices[j + 1]
                || output.Indices[j] == output.Indices[j + 2]
                || output.Indices[j + 1] == output.Indices[j + 2]) { // 消除退化的面
                output.Indices.erase(output.Indices.begin() + j, output.Indices.begin() + j + 3);
                j -= 3;
            }
        }

        // 顶点对合并
        pair_vis[min_pair] = 1;
        for (size_t j = 0; j < pair_cnt; j++) {
            if (pair_vis[j]) continue;

            if (v_pair[j].first == v_pair[min_pair].second) {
                v_pair[j].first = v_pair[min_pair].first;
            }
            if (v_pair[j].second == v_pair[min_pair].second) {
                v_pair[j].second = v_pair[min_pair].first;
            }

            if (v_pair[j].first > v_pair[j].second) { // 保持顶点对的大小序
                size_t tmp       = v_pair[j].second;
                v_pair[j].second = v_pair[j].first;
                v_pair[j].first  = tmp;
            } else if (v_pair[j].first == v_pair[j].second) {
                pair_vis[j] = 1; // 消除退化的顶点对
                continue;
            } else { // 检测距离
                if (t <= 0) continue;
                glm::vec3 v1 = output.Positions[v_pair[j].first],
                          v2 = output.Positions[v_pair[j].second];
                if ((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y)
                        + (v1.z - v2.z) * (v1.z - v2.z)
                    > t) {
                    pair_vis[j] = 1;
                }
            }
        }

        // 更新收缩点和代价
        Q[v_pair[min_pair].first] += Q[v_pair[min_pair].second];
        for (size_t j = 0; j < pair_cnt; j++) {
            if (pair_vis[j]) continue;
            if (v_pair[j].first == v_pair[min_pair].first
                || v_pair[j].second == v_pair[min_pair].first) {
                size_t    v1 = v_pair[j].first, v2 = v_pair[j].second;
                glm::mat4 q = Q[v1] + Q[v2];
                // 注意glm::mat4按列存储
                glm::mat4 tmp_mat = glm::mat4(
                    q[0][0],
                    q[0][1],
                    q[0][2],
                    0,
                    q[0][1],
                    q[1][1],
                    q[1][2],
                    0,
                    q[0][2],
                    q[1][2],
                    q[2][2],
                    0,
                    q[0][3],
                    q[1][3],
                    q[2][3],
                    1);
                glm::mat4 inv_mat = glm::inverse(tmp_mat);
                glm::vec4 v_bar   = inv_mat * glm::vec4(0, 0, 0, 1);
                pair2point[j]     = v_bar;
                pair2cost[j]      = v_bar.x * ((q * v_bar).x) + v_bar.y * ((q * v_bar).y)
                    + (v_bar.z * (q * v_bar).z) + (v_bar.w * (q * v_bar).w);
            }
        }
    }
}