# **Lab3 Report**

## Task 1: Phong Illumination 

在这个任务中，我们实现了Phong光照模型。Phong光照模型主要包含了3个部分的光照：环境光，漫反射和镜面反射。在我们实现的函数中，只包含漫反射和镜面反射。为了实现方便，我自己添加了一个函数`float vec_cos(vec3 d1,vec3 d2)`，该函数输入为两个向量，如果它们夹角的余弦值大于0，那么返回夹角的余弦值，否则返回0。然后只需要按照课件上的公式求出光照即可。对于Blinn-Phoong的渲染方式，只要在计算角度的时候使用对应的公式即可。此外，我还实现了凹凸映射，
**问题1：**
顶点着色器的输入为顶点相关的信息，如位置、法向量等等，输出为顶点的颜色。片段着色器为输入为一个vec4颜色变量，输出为最终的颜色，我们一般将顶点着色器的输出作为片段着色器的输入。为了将从顶点着色器向片段着色器发送数据，我们只需要在顶点着色器中声明一个输出，在片段着色器中声明一个同名的输入，这时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了。
**问题2：**
`diffuseFactor.a`的值代表了当前这个顶点的透明度，当透明度为0的时候，光线会完全穿过顶点，而当透明度比较小的时候大部分光线也会穿过。所以我们应当设定一个阈值,当透明度小于这个阈值时，我们认为光线穿过，显然这个阈值是大于0的，我们设置成$0.2$会比较合理。

## Task 2: Environment Mapping
在这一部分中，我实现了立方体贴图。我们代码实现的部分主要包括

## Task 3: Non-Photorealistic Rendering
在这一部分中，我实现了一个非真实感渲染算法。我实现的部分主要是使用Gooch Shading来渲染物体的正面。
首先我根据光照方向和法向来计算冷暖色，然后使用课件上的公式来计算颜色。最终得到的效果如下图所示。
**问题1：**
首先确定了光照的角度，从光照的角度观察，根据深度来确定正面和背面。
**问题2：**



## Task 4: Shadow Mapping
在这一部分中，我实现了点光源和有向光源的阴影效果。

## Task 5: Whitted-Style Ray Tracing
在这个任务中，我实现了光线追踪算法。首先，我实现了`bool IntersectTriangle(Intersection & output, Ray const & ray， glm::vec3 const & p1, glm::vec3 const & p2, glm::vec3 const & p3)` 函数来求光线 `ray` 与三角形 `(p1, p2, p3)` 之间的交点。其中，我使用的方法为[Fast, minimum storage ray/triangle intersection](https://dl.acm.org/doi/10.1145/1198555.1198746)中提供的算法。将光线参数化成$p+td$，三角形内的点可以参数化为$p_0+u(p_1-p_0)+v(p_2-p_0)$，其中，$p,p_0,p_1,p_2$分别为光源的位置、三角形的三个顶点，$d$为光的方向，$t,u,v$为待求的参数。光线与平面相交有$p+td=p_0+u(p_1-p_0)+v(p_2-p_0)$，所以我们可以解出$t,u,v$。如果满足$t,u,v>0$且$u+v<1$则交点在三角内，从而光线与三角形相交，否则，不相交。然后就是光线追踪的主体算法。对于每一条发出的射线，我首先查看这条射线是否与物体相交。如果射线不与任何物体相交，那么直接返回背景的颜色。否则，我们根据公式直接计算出交点的颜色，然后根据交点的情况来决定射线穿过物体继续传播，还是发生反射，还是终止传播。如果射线穿过物体或是发生反射，我们直接将重置射线的起点和方向即可。另外，我们还要考虑阴影的情况，所以，在计算射线和物体交点的颜色时，我们还要计算光源与交点之间是否有遮挡物体。我们只需要从物体向光源发射一条射线来判断交点到光源之间是否有不透明的物体，每次碰到透明的物体，我们只要重新设置射线的起点然后发射新的射线，知道碰到不透明的物体或是确定没有不透明的物体为止。